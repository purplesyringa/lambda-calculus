<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Начало &mdash; &lambda;-calculus</title>

		<link rel="stylesheet" type="text/css" href="css/main.css">
		<link rel="stylesheet" type="text/css" href="css/highlighting.css">
	</head>
	<body>
		<h1><b>&lambda;</b>-calculus</h1>
		<h2>I. Начало</h2>


		<nav>
			<a></a>
			<a href="pt2.html">II. Управление поведением &rightarrow;</a>
		</nav>


		<h3>Функции высшего порядка</h3>

		<p>
			Начнем с несколько отстраненной темы. В математике полно функций &mdash; алгебраических вроде <code>exp</code>, тригонометрических вроде <code>sin</code> и других. Функции можно задавать и руками, например:
		</p>

		<pre>f(x) = 2x + 1</pre>

		<p>
			Эта запись появилась еще в 18 веке, когда никакой речи об анализе функций с той точки зрения, с которой мы их рассмотрим, идти не могло. Все, что означает эта запись &mdash; это что
		</p>

		<pre>
f(1) = 2*1 + 1
f(2) = 2*2 + 1
f(3) = 2*3 + 1
...
</pre>

		<p>
			и так далее.
		</p>

		<p>
			Но есть одно "но", которое перечеркивает все удобства. Проблема в том, что <code>f(x) = 2x + 1</code> утверждает, что буква <code>f</code>, за которой следует открывающая скобка, затем какое-то выражение, затем закрывающая скобка, обозначает такое-то значение. О том, что означает сама буква <code>f</code> по отдельности &mdash; речи не идет, и даже из контекста это не всегда понятно.
		</p>

		<p>
			Попробуйте как программист упростить следующую запись:
		</p>

		<pre>
f(x) = sin(sin(sin(x))) + cos(cos(cos(x))) + tg(tg(tg(x))) + ctg(ctg(ctg(x)))
</pre>

		<p>
			У этой задачи есть очевидное (для программиста), изящное и понятное решение:
		</p>

		<pre>
rep(x, g) = g(g(g(x)))
f(x) = rep(x, sin) + rep(x, cos) + rep(x, tg) + rep(x, ctg)
</pre>

		<p>
			Вот только неправильное. Потому что в алгебре сами по себе три буквы <code>sin</code> ничего не означают, тем более &mdash; если они подаются как параметр какой-то еще функции. Перефразируя: в классической математике нет способа воспользоваться функцией, кроме как сразу ее применить к какому-либо аргументу. Говоря формально: в классической математике нет функций высшего порядка.
		</p>

		<p>
			Для того, чтобы названия функций имели смысл сами по себе, а не только при применении к какому-либо аргументу, вводят дополнительную нотацию. Было:
		</p>

		<pre>f(x) = 2x+1</pre>

		<p>Стало:</p>

		<pre>f := \x. 2x+1</pre>

		<p>
			Знак &lambda; (лямбда) обозначает функцию. После него идет название аргумента, затем точка, затем &mdash; выражение, по которому функция вычисляется. Дальше с функциями можно работать, как в обычной математике:
		</p>

		<pre>
double := \x. x*2
triple := \x. x*3
x_five := \x. (double(x)) + (triple(x))
</pre>


		<h3>Каррирование</h3>

		<p>
			Если мы попробуем теперь правильно расписать функцию "rep", нас ожидает сюрприз. &lambda;-функция всегда принимает ровно один аргумент. А если нужно больше? Для этого мы используем трюк, называемый каррированием. Мы определим функцию, которая принимает первый аргумент и возвращает новую функцию, которая принимает второй аргумент и возвращает еще одну функцию, которая принимает третий аргумент, и так далее. Последняя функция примет последний аргумент и вернет собственно результат. Вот так, например, можно определить сложение:
		</p>

		<pre>add := \a. \b. a + b</pre>

		<p>
			Если, например, формально посчитать <code>add 1</code>, то получится <code>\b. 1 + b</code> &mdash; функция возвращает другую функцию. Теперь, если эту новую функцию опять применить к числу, скажем, два, получится <code>1 + 2</code>, то есть <code>3</code>.
		</p>

		<pre>(add(1))(2) = 3</pre>

		<p>
			Поскольку много скобок ставить неудобно, есть два упрощения. Во-первых, <code>f x</code> &mdash; это то же самое, что <code>f(x)</code>. Во-вторых, поскольку каррирование используется очень часто, то <code>f x y</code> &mdash; это то же самое, что <code>(f x) y</code>. Упрощая:
		</p>

		<pre>add 1 2 = 3</pre>

		<p>
			Вот, кстати, как тот пример с <code>rep</code> записывается правильно:
		</p>

		<pre>
rep := \x. \g. g(g(g x))
f := \x. (rep x sin) + (rep x cos) + (rep x tg) + (rep x ctg)
</pre>


		<h3>Вычисления</h3>

		<p>
			В &lambda;-исчислении выражения составляются при помощи создания &lambda;-функций и применения их друг к другу.
		</p>

		<p>
			Давайте формально определим, что значит "вычислить выражение". Для этого можно проводить над выражением друг за другом следущие операции:
		</p>

		<ol>
			<li>&alpha;-эквивалентность. Это математический аналог переименования переменных. Например: <code>\x. x*2+t</code> можно заменить на <code>\y. y*2+t</code>.</li>

			<li>&beta;-редукция. Это математический аналог вызова функции. Выражение вида <code>(\x.E1)(E2)</code> можно заменить на <code>E1</code>, в котором все вхождения <code>x</code> заменяются на <code>E2</code>. Например: <code>(\x. 2*x+1)(1+2)</code> можно заменить на <code>2*(1+2)+1</code>.</li>

			<li>&eta;-преобразование. Это утверждение о том, что функции задаются своими значениями во всех точках и не имеют внутренней структуры. Выражение вида <code>\x.(E x)</code> разрешается заменить на <code>E</code> (конечно, только если <code>x</code> не используется внутри <code>E</code>). Например: <code>\x.(sin x)</code> &mdash; это то же самое, что <code>sin</code>. К слову, почему это интуитивно очевидное правило нужно вводить отдельно: в некоторых областях математики для задания функции недостаточно ее значений во всех точках. Например, если мы исследуем полиномы по модулю именно как полиномы, а не как функции. Например, если вычисления проводятся по модулю 2, <code>x^2 + x + 1</code> &mdash; это не то же самое, что <code>1</code>.</li>
		</ol>

		<p>
			Для вычисления значений выражений мы будем применять в каком-то порядке эти операции. Вообще говоря, в большинстве случаев достаточно &beta;-редукции, но об этом чуть позже. Применять эти операции мы будем, пока не получится выражение, в котором нет вызовов функций. Такое выражение называется &beta;-нормальной формой.
		</p>


		<h3>Арифметика</h3>

		<p>
			Теперь предлается немного расширить границы применимости &lambda;-исчисления. В самом деле, у нас такая стройная теория, а <code>5 + 7</code> мы все еще считаем используя какую-то арифметику. Пора от этого избавляться.
		</p>

		<p>
			Итак, отныне каждый раз, когда в коде будут использоваться числа, мы будем интерпретировать их как специальные &lambda;-функции, а именно:
		</p>

		<pre>
0 := \f. \x. x
1 := \f. \x. f x
2 := \f. \x. f(f x)
3 := \f. \x. f(f(f x)
4 := \f. \x. f(f(f(f x))
...
</pre>

		<p>
			Словом, число <code>n</code> &mdash; это &lambda;-функция, которая принимает два аргумента (ну, через каррирование): <code>f</code> и <code>x</code>, а затем <code>n</code> раз применяет <code>f</code> к <code>x</code>. Например: <code>3 g y = g(g(g y)))</code>, а <code>3 g = \x. g(g(g x))</code> (так сказать, утроение функции).
		</p>

		<p>
			Теперь мы можем реализовать, например, инкремент (<code>succ</code> &mdash; сокращение от successor, следующий):
		</p>

		<pre>succ := \n. \f. \x. n f (f x)</pre>

		<p>
			Иными словами, <code>succ</code> принимает число <code>n</code>, и возвращает нечто. Когда это нечто вызывается от <code>f</code> и <code>x</code>, оно не сразу передает эти два аргумента числу <code>n</code>, а сначала лишний раз применяет <code>f</code> к <code>x</code> &mdash; вот и получается на один больше. Если вы любите формальности, вот вам пример с вычислением &beta;-редукциями:
		</p>

		<pre>
succ 3 ->
-> \f. \x. 3 f (f x) ->
-> \f. \x. (\g. \y. g(g(g y))) f (f x) ->
-> \f. \x. (\y. f(f(f y))) (f x) ->
-> \f. \x. f(f(f(f x))) = 4
</pre>

		<p>
			Теперь можно реализовать и сложение. Сложение <code>a</code> и <code>b</code> &mdash; это значит <code>a</code> раз применить <code>succ</code> к <code>b</code>. Записывается это на удивление просто:
		</p>

		<pre>add := \a. \b. a succ b = \a. a succ</pre>

		<p>
			Дальше по списку идет умножение. Здесь проще воспользоваться пониманием числа как умножителя функции. Произведение <code>a</code> на <code>b</code> &mdash; это нечто, принимающее функцию и повторяющее ее <code>a*b</code> раз. Для этого достаточно ее сначала повторить <code>b</code> раз, затем результат &mdash; <code>a</code> раз:
		</p>

		<pre>mul := \a. \b. \f. a (b f)</pre>

		<p>
			Например:
		</p>

		<pre>
mul 2 3 ->
-> \f. 2 (3 f) ->
-> \f. 2 ((\g. \y. g(g(g y))) f) ->
-> \f. 2 (\y. f(f(f y))) ->
-> \f. (\g. \x. g(g x)) (\y. f(f(f y))) ->
-> \f. \x. (\y. f(f(f y))) ((\y. f(f(f y))) x) ->
-> \f. \x. (\y. f(f(f y))) (f(f(f x))) ->
-> \f. \x. f(f(f(f(f(f x))))) = 6
</pre>

		<p>
			Чтобы вы почувствовали всю красоту &lambda;-исчисления, реализуем еще возведение в степень <code>pow a b</code>. <code>pow a b</code> &mdash; это то же самое, что <code>\f. a (a (... (a f)))</code>, где <code>a</code> повторяется <code>b</code> раз. Погодите-ка, повторение функции &mdash; это же ровно то, как числа и определены!
		</p>

		<pre>pow := \a. \b. b a</pre>

		<p>
			Несколько сложнее ввести декремент и вычитание: проблема в том, что понять, что значит "применить функцию <code>-1</code> раз" &mdash; не самое простое дело. К этой задаче мы вернёмся чуть позже. А в следующей части займёмся логикой.
		</p>


		<nav>
			<a></a>
			<a href="pt2.html">II. Управление поведением &rightarrow;</a>
		</nav>


		<script type="text/javascript" src="js/highlighting.js"></script>
	</body>
</html>
