<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Очищение &mdash; &lambda;-calculus</title>

		<link rel="stylesheet" type="text/css" href="css/main.css">
		<link rel="stylesheet" type="text/css" href="css/highlighting.css">
	</head>
	<body>
		<h1><b>&lambda;</b>-calculus</h1>
		<h2>VII. Очищение</h2>


		<nav>
			<a href="pt6.html">&leftarrow; VI. Библиотеки и рекурсия</a>
			<a></a>
		</nav>


		<h3>Правильные &beta;-редукции</h3>

		<p>
			Теперь давайте рассмотрим проблемы &lambda;-исчисления. Одна из проблем &mdash; чисто техническая, да и вы, наверное, ее уже замечали выше по тексту. Пусть у нас есть какое-нибудь хитрое выражение, например:
		</p>

		<pre>(\y. y y) (\f. \x. f x)</pre>

		<p>
			Если попробовать делать &beta;-редукции втупую, подстановкой, то получится:
		</p>

		<pre>
(\y. y y) (\f. \x. f x) ->
-> (\f. \x. f x) (\f. \x. f x) ->
-> \x. (\f. \x. f x) x ->
-> \x. \x. x x
</pre>

		<p>
			Появляется проблема: в конце непонятно, к чему относится каждая переменная &mdash; к параметру внешней или внутренней &lambda;-функции.
		</p>

		<p>
			Такая проблема возникает, когда у аргумента есть свободные переменные, которые после подстановки ошибочно оказываются связанными не с той &lambda;-функцией. Чтобы этого избежать, можно совершать дополнительные переименования во время вычислений.
		</p>


		<h3>SKI-базис</h3>


		<p>
			Но что, если бы мы смогли избавиться от переменных?
		</p>

		<p>
			Как известно, в &lambda;-исчислении есть много комбинаторов, то есть функций, не использующих внешние переменные. С Y-комбинатором мы уже знакомы, введем еще три, на этот раз гораздо более простых:
		</p>

		<pre>
S := \f. \g. \x. (f x) (g x)
K := \x. \y. x
I := \x. x
</pre>

		<p>
			<code>I</code> &mdash; самый простой комбинатор, возвращающий свой аргумент.
		</p>

		<p>
			<code>K</code> &mdash; уже известный нам как <code>true</code> комбинатор, который принимает два аргумента и всегда возвращает первый.
		</p>

		<p>
			<code>S</code> &mdash; что-то новое. Его смысл можно понять так: если написать, скажем, <code>f (g x)</code>, то аргумент <code>x</code> получит только функция <code>g</code>, а не функция <code>f</code>. Если расставить скобки по-другому или поменять местами аргументы &mdash; все равно аргумент <code>x</code> получит только одна функция. А если мы хотим его передать обоим функциям? Для этого и нужен этот комбинатор: <code>S f g x =b (f x) (g x)</code>.
		</p>

		<p>
			Так вот, оказывается, что абсолютно любой терм выражается как комбинация этих термов, вообще без создания новых функций через <code>\x.</code>! Следите за руками.
		</p>

		<p>
			Мы будем мысленно брать выражение и рекурсивно переписывать его на комбинацию комбинаторов (ну, вы поняли). Выражение это может выглядеть совершенно по-разному.
		</p>


		<ul>
			<li>
				<p>
					Пусть, например, оно имеет такой вид: <code>\x. E1 E2</code> (<code>x</code>, конечно, может участвовать в обоих подвыражениях). Его мы перепишем следующим образом: <code>\t. ((\x. E1) t) ((\x. E2) t)</code>. Таким образом мы как бы проталкиваем <code>\x.</code> внутрь двух выражений. Теперь заметим, что это можно переписать через комбинатор <code>S</code>: <code>S (\x. E1) (\x. E2)</code>. Например:
				</p>
				<pre>\x. 5 (succ x) =b S (\x. 5) (\x. succ x)</pre>
				<p>
					Для того, чтобы до конца преобразовать это выражение в SKI-базис, мы рекурсивно запустимся от <code>\x. 5</code> и <code>\x. succ x</code>, и так далее. Формально:
				</p>
				<pre>rewrite[\x. E1 E2] := S rewrite[\x. E1] rewrite[\x. E2]</pre>
			</li>

			<li>
				<p>
					Вообще, давайте до конца поймем, как преобразуются определения функций. С <code>\x. E1 E2</code> все ясно, еще возможен вариант <code>\x. \y. E</code>, где <code>E</code> зависит и от <code>x</code>, и от <code>y</code>. Тогда мы сначала преобразуем <code>\y. E</code> в SKI-базис и получим выражение вроде <code>\x. E2</code>, где теперь в <code>E2</code> уж точно нет определений функций &mdash; итого, свели к первому случаю.
				</p>
				<pre>rewrite[\x. \y. E] := rewrite[\x. rewrite[\y. E]]</pre>
				<p>
					Осталось два исключения: <code>\x. x</code> и <code>\x. t</code>.
				</p>
			</li>

			<li>
				<p>
					<code>\x. x</code> &mdash; это просто I-комбинатор:
				</p>
				<pre>rewrite[\x. x] := I</pre>
			</li>

			<li>
				<p>
					И последний вариант &mdash; когда функция есть, а ее параметр не используется. Например, как <code>\x. t</code> в примере выше. Иначе говоря, мы хотим выразить константную функцию. На самом деле, этим и занимается K-комбинатор: <code>\x. t =b K t</code>.
				</p>
				<pre>rewrite[\x. t] := K rewrite[t]</pre>
			</li>

			<li>
				<p>
					Все варианты вида <code>\x. E</code> уже разобраны, остались варианты вне функций. Первый &mdash; <code>E1 E2</code>, тут все просто:
				</p>
				<pre>rewrite[E1 E2] := rewrite[E1] rewrite[E2]</pre>
			</li>

			<li>
				<p>
					Ну и наконец, вообще самый базовый случай, когда выражение никак не раскладывается на подтермы, потому что оно является одной переменной:
				</p>
				<pre>rewrite[x] := x</pre>
			</li>
		</ul>

		<p>
			Вообще говоря, при таких тупых заменах может образоваться что-то вроде <code>\x. f x</code>, что раскроется как
		</p>

		<pre>rewrite[\x. f x] = S rewrite[\x. f] rewrite[\x. x] = S (K f) I</pre>

		<p>
			в то время как <code>f</code> &mdash; гораздо более короткое решение, поэтому нередко к этим же пунктам добавляют &eta;-преобразование.
		</p>

		<p>
			Хотите потренироваться и преобразовать в SKI-базис Y-комбинатор? Нет? А я хочу. Для краткости возьмем асимметричный Y-комбинатор.
		</p>

		<pre>
rewrite[Y] =
= rewrite[\f. (\x. x x) (\x. f (x x))] =
= S rewrite[\f. \x. x x] rewrite[\f. \x. f (x x)] =
= S (K rewrite[\x. x x]) rewrite[\f. \x. f (x x)] =
= S (K (S rewrite[\x. x] rewrite[\x. x])) rewrite[\f. \x. f (x x)] =
= S (K (S I I)) rewrite[\f. \x. f (x x)] =
= S (K (S I I)) rewrite[\f. rewrite[\x. f (x x)]] =
= S (K (S I I)) rewrite[\f. S rewrite[\x. f] rewrite[\x. x x]] =
= S (K (S I I)) rewrite[\f. S (K f) rewrite[\x. x x]] =
= S (K (S I I)) rewrite[\f. S (K f) (S rewrite[\x. x] rewrite[\x. x])] =
= S (K (S I I)) rewrite[\f. S (K f) (S I I)] =
= S (K (S I I)) (S rewrite[\f. S (K f)] rewrite[\f. (S I I)]) =
= S (K (S I I)) (S rewrite[\f. S (K f)] (K (S I I))) =
= S (K (S I I)) (S (S rewrite[\f. S] rewrite[\f. K f]) (K (S I I))) =
= S (K (S I I)) (S (S (K S) rewrite[\f. K f]) (K (S I I))) =
= S (K (S I I)) (S (S (K S) K) (K (S I I)))
</pre>

		<p>
			Красота.
		</p>


		<h3>SK-базис</h3>

		<p>
			Да, кстати, кроме SKI-базиса исследуется также SK-базис. Дело в том, что комбинатор <code>I</code> можно выразить через комбинаторы <code>S</code> и <code>K</code>.
		</p>

		<p>
			Как ни удивительно, самый простой терм <code>\x. x</code> выражается в SK-базисе не так очевидно. Чтобы понять, как тут быть, заметим, что <code>\x. x =b \x. K x (...)</code>, где <code>...</code> &mdash; произвольный терм. Для симметрии пусть <code>... := K x</code>, тогда <code>\x. x =b \x. (K x) (K x)</code>. Что-то очень похожее с распределением аргумента мы видели раньше &mdash; в S-комбинаторе. И правда: <code>\x. x =b S K K</code>.
		</p>

		<p>
			С помощью этого мы можем упростить SKI-базис до SK-базиса. Y-комбинатор в нем записывается так:
		</p>

		<pre>S (K (S (S K K) (S K K))) (S (S (K S) K) (K (S (S K K) (S K K))))</pre>


		<h3>&iota;-базис</h3>

		<p>
			Шо, опять? Да, можно еще эффективнее. У нас уже есть базис из двух комбинаторов, так давайте построим базис из одного комбинатора. Засунем S и K в один &iota;-комбинатор в виде пары:
		</p>

		<pre>i := pair S K -> \f. f S K</pre>

		<p>
			Теперь у нас есть только &iota;, так что давайте просто переберем варианты комбинации йот.
		</p>

		<pre>
i i ->
-> (\f. f S K) i ->
-> i S K ->
-> (\f. f S K) S K ->
-> (S S K) K ->
-> (S K) (K K) ->
-> \y. S K (K K) y ->
-> \y. (K y) (K K y) ->
-> \y. (\x. y) (K K y) ->
-> \y. y ->
-> I
</pre>

		<p>
			Неожиданно, но приятно. Ясно, что <code>(i i) i -> I i -> i</code> особо бесполезно, так что попробуем теперь группировать скобки по-другому.
		</p>

		<pre>
i (i i) ->
-> i I ->
-> I S K ->
-> S K
</pre>

		<p>
			Это ни на что не похоже, давайте еще накинем йот.
		</p>

		<pre>
i (i (i i)) ->
-> i (S K) ->
-> S K S K ->
-> (K K) (S K) ->
-> K
</pre>

		<p>
			Интересно. Еще одну йоту?
		</p>

		<pre>
i (i (i (i i))) ->
-> i K ->
-> K S K ->
-> S
</pre>

		<p>
			Да, это было хорошей идеей. Пожалуйста, вот вам S, K, I комбинаторы в &iota;:
		</p>

		<pre>
S =b i (i (i (i i)))
K =b i (i (i i))
I =b i i
</pre>

		<p>
			Таким образом, применяя &iota;-комбинатор в различных комбинациях, можно выразить любой терм.
		</p>

		<p>
			Ну как, хотите Y-комбинатор в &iota;-базисе?
		</p>

		<pre>(i (i (i (i i)))) ((i (i (i i))) ((i (i (i (i i)))) (i i) (i i))) ((i (i (i (i i)))) ((i (i (i (i i)))) ((i (i (i i))) (i (i (i (i i))))) (i (i (i i)))) ((i (i (i i))) ((i (i (i (i i)))) (i i) (i i))))</pre>

		<p>
			А как вам &iota;-язык? Выражение, записанное в &iota;-базисе &mdash; это, по сути, бинарное дерево. Листья &mdash; собственно &iota;-комбинаторы, остальные вершины &mdash; вызовы функций. Если в листы записать единицы, а в остальные вершины &mdash; нули, а потом пройтись по этому дереву dfs'ом и выписать цифры в вершинах, получится выражение на &iota;-языке. Например, <code>i (i i)</code> кодируется как <code>01011</code>. А вот как кодируется Y-комбинатор:
		</p>

		<pre>00010101011001010110001010101101101100010101011000101010110010101101010101101010110010101100010101011011011</pre>


		<nav>
			<a href="pt6.html">&leftarrow; VI. Библиотеки и рекурсия</a>
			<a></a>
		</nav>


		<script type="text/javascript" src="js/highlighting.js"></script>
	</body>
</html>
