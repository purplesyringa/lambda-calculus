<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Библиотеки и рекурсия &mdash; &lambda;-calculus</title>

		<link rel="stylesheet" type="text/css" href="css/main.css">
		<link rel="stylesheet" type="text/css" href="css/highlighting.css">
	</head>
	<body>
		<h1><b>&lambda;</b>-calculus</h1>
		<h2>VI. Библиотеки и рекурсия</h2>


		<nav>
			<a href="pt5.html">&leftarrow; V. Списки</a>
			<a href="pt7.html">VII. Очищение &rightarrow;</a>
		</nav>


		<h3>Что скрывается за сахаром?</h3>

		<p>
			Мы вводим определения, внутри которых только создаем и применяем функции. И этого уже достаточно, чтобы реализовать что угодно! Но можно ли еще что-то выбросить, чтобы дальше упросить нашу модель?
		</p>

		<p>
			Теперь мы начнем работать в неожиданную и, можно сказать, противоположную сторону: мы будем избавляться от присваиваний. Ну, то есть, пусть мы хотим вычислить выражение, а оно использует какие-то другие функции, которые определены раньше через <code>f := ...</code>. От такого мы будем избавляться. Пусть, например, у нас было что-то в духе:
		</p>

		<pre>
rep := \x. \g. g(g(g x))
f := \x. add (rep x sin) (rep x cos)
</pre>

		<p>
			И нас интересует значение <code>f 3</code>. Тогда определение <code>f</code> я заменю на такое:
		</p>

		<pre>f := (\rep. \x. add (rep x sin) (rep x cos)) (\x. \g. g(g(g x)))</pre>

		<p>
			Что тут произошло: мы сначала сделали функцию, которая принимает параметр <code>rep</code>, а затем в качестве этого параметра передали ей собственно функцию <code>rep</code>. Ясно, что программа все еще работает. При этом код даже почти не увеличился в объеме.
		</p>

		<p>
			Далее, раскроем <code>f 3</code>:
		</p>

		<pre>
			(\rep. \x. add (rep x sin) (rep x cos)) (\x. \g. g(g(g x))) (3)
</pre>

		<p>
			Теперь получилась "программа", в которой нет присвоения переменных, то есть просто выражение. Вообще, в общем случае это:
		</p>

		<pre>
a := E1
E2 ->> ?
</pre>

		<p>
			Эквивалентно этому:
		</p>

		<pre>(\a. E2)(E1) ->> ?</pre>

		<p>
			Но с рекурсивными функциями это становится нетривиальной задачей. Кстати, на счет рекурсивных функций. Давайте для примера реализуем вычисление факториала.
		</p>

		<pre>fact := \n. ...</pre>

		<p>
			Если число <code>n</code> &mdash; нуль, сразу можно закончить и вернуть единицу:
		</p>

		<pre>fact := \n. (iszero n) 1 ...</pre>

		<p>
			Если нет &mdash; вызовемся рекурсивно от <code>n - 1</code> и умножим результат на <code>n</code>:
		</p>

		<pre>fact := \n. (iszero n) 1 (mul n (fact (pred n)))</pre>

		<p>
			Ну и теперь осталось избавиться от присвоений. Пусть, например, мы хотим посчитать <code>fact 4</code>:
		</p>

		<pre>
fact := \n. (iszero n) 1 (mul n (fact (pred n)))
fact 4
</pre>

		<p>
			Пробуем:
		</p>

		<pre>(\fact. fact 4) (\n. (iszero n) 1 (mul n (fact (pred n))))</pre>

		<p>
			Нда. Теперь у нас семантическая ошибка. Функция-то рекурсивная, а переменная <code>fact</code> внутри самой функции не определена. Проблемка. Придется что-нибудь придумывать.
		</p>


		<h3>Правильная рекурсия</h3>


		<p>
			На этом моменте я предлагаю немного отвлечься и вспомнить про похожие проблемы в других языках. Например, в C++. Точно так же я определю рекурсивную функцию:
		</p>

		<pre>
void dfs(int u) {
    for (int v : adj[u]) {
        dfs(v, u);
    }
}

void solve() {
    dfs(0);
}
</pre>

		<p>
			Теперь попробую ее перенести внутрь <code>solve</code> в виде лямбда-функции:
		</p>

		<pre>
void solve() {
    auto dfs = [](int u) {
        for (int v : adj[u]) {
            dfs(v, u);
        }
    };

    dfs(0);
}
</pre>

		<p>
			И ничего у меня не получится, потому что <code>auto</code> пытается определить тип лямбда-функции, а она использует внутри себя переменную <code>dfs</code>, тип которой еще не определен. Рекурсия.
		</p>

		<p>
			Тогда я воспользуюсь широко известным в узких кругах трюком: я передам <code>dfs</code>'у в качестве нового первого параметра его самого:
		</p>

		<pre>
void solve() {
    auto dfs = [](auto dfs, int u) {
        for (int v : adj[u]) {
            dfs(dfs, v, u);
        }
    };

    dfs(dfs, 0);
}
</pre>

		<p>
			Вернемся к факториалу.
		</p>

		<ol>
			<li>
				<p>С этого мы начинали:</p>
				<pre>
fact := \n. (iszero n) 1 (mul n (fact (pred n)))
fact 4
</pre>
			</li>

			<li>
				<p>Сделаем замену, как с <code>dfs</code>'ом, чтобы факториал мог вызывать сам себя изнутри:</p>
				<pre>
fact1 := \fact1. \n. (iszero n) 1 (mul n (fact1 fact1 (pred n)))
fact1 fact1 4
</pre>
			</li>

			<li>
				<p><code>fact1 fact1</code> писать каждый раз при вызове неудобно &mdash; вынесем это отдельно в функцию <code>fact</code>:</p>
				<pre>
fact1 := \fact1. \n. (iszero n) 1 (mul n (fact1 fact1 (pred n)))
fact := fact1 fact1
fact 4
</pre>
			</li>

			<li>
				<p>Для удобства и симметрии <code>fact1 fact1</code> внутри определения функции тоже оптимизируем. Здесь можно было бы написать <code>fact</code>, но тогда мы от рекурсии никак не избавимся. Вместо этого просто вынесем <code>fact1 fact1</code> в параметр функции, которую мы тут же вызываем, как раньше делали в нерекурсивными функциями:</p>
				<pre>
fact1 := \fact1. (\fact. \n. (iszero n) 1 (mul n (fact (pred n)))) (fact1 fact1)
fact := fact1 fact1
fact 4
</pre>
			</li>

			<li>
				<p>Вставим определение <code>fact1</code> внутрь <code>fact</code>:</p>
				<pre>
fact := (\fact1. fact1 fact1) (\fact1. (\fact. \n. (iszero n) 1 (mul n (fact (pred n)))) (fact1 fact1))
fact 4
</pre>
			</li>

			<li>
				<p>
					В принципе, здесь уже можно было бы остановиться, но мы пойдем дальше. Внутренняя часть определения <code>fact</code> смахивает на изначальное (рекурсивное) определение, так что вынесем-ка его ради интереса пока в отдельную переменную.
				</p>
				<pre>
factrec := \factrec. \n. (iszero n) 1 (mul n (factrec (pred n)))
fact := (\fact1. fact1 fact1) (\fact1. factrec (fact1 fact1))
fact 4
</pre>
			</li>

			<li>
				<p>Немного переименуем переменные:</p>
				<pre>
factrec := \factrec. \n. (iszero n) 1 (mul n (factrec (pred n)))
fact := (\x. x x) (\x. factrec (x x))
fact 4
</pre>
			</li>

			<li>
				<p>
					Смотрите-ка, что произошло. Мы реализовали <code>factrec</code>, как реализовывали бы обычную рекурсивную функцию, но с одним исключением &mdash; добавили в начале <code>\factrec.</code>. Это, можно считать, неожиданный синтаксический прием. Затем мы по определенному правилу преобразовали <code>factrec</code> в функцию <code>fact</code>, которую можно использовать как любую обычную функцию. А нельзя ли это проделать не только для факториала, но и для других функций? Можно. Чтобы яснее это увидеть и понять, что вообще произошло, вынесем это правило преобразования в отдельную функцию.
				</p>
				<pre>
factrec := \factrec. \n. (iszero n) 1 (mul n (factrec (pred n)))
Y := \f. (\x. x x) (\x. f (x x))
fact := Y factrec
fact 4
</pre>
			</li>

			<li>
				<p>
					Вообще говоря, такая функция (<code>Y</code>, в этом примере) &mdash; комбинатор. Напомню, комбинаторы &mdash; это такие функции, которые не используют никакие внешние (свободные) переменные. Давайте для красоты проведем еще один раз &beta;-редукцию функции <code>Y</code>:
				</p>
				<pre>
Y := \f. (\x. f (x x)) (\x. f (x x))
</pre>
			</li>

			<li>
				<p>
					И последний шаг, избавимся от <code>factrec</code>. Как удивительно просто стало писать рекурсивные функции без рекурсивных определений, а?
				</p>
				<pre>
Y := \f. (\x. f (x x)) (\x. f (x x))
fact := Y (\fact. \n. (iszero n) 1 (mul n (fact (pred n))))
fact 4
</pre>
			</li>
		</ol>

		<p>
			Рефлексия. Была рекурсивная функция <code>fact := ... fact ...</code>, которая использовала свое имя внутри себя. Мы ее заменили на функцию <code>fact := Y (\fact. ... fact ...)</code>, которая с точки зрения пользователя выглядит и работает так же и синтаксис использует очень похожий, но зато не использует внутри себя свое же имя. А значит, теперь можно использовать наши старые методы для того, чтобы окончательно избавиться от присвоений.
		</p>

		<p>
			Теперь мы можем писать программы, используя только создание и применение &lambda;-функций!
		</p>


		<h3>Еще пару слов про Y-комбинатор</h3>

		<p>
			По сути, в нашем примере мы сначала сделали функцию, принимающую факториал и реализующую на его основе сам же факториал, после чего передали ее в Y-комбинатор, и получили готовый факториал:
		</p>

		<pre>
fact_generator := \fact. \n. (iszero n) 1 (mul n (fact (pred n)))
fact := Y fact_generator
</pre>

		<p>
			То есть Y-комбинатор принимает функцию, создающую объект на основе самого себя, и возращает нам готовый объект. Рекурсия в самом ее общем виде.
		</p>

		<p>
			Y-комбинатор позволяет не только рекурсивно вычислять что-то конечное, но и рекурсивно создавать бесконечные структуры данных. Например, список всех натуральных чисел, или список всех простых чисел.
		</p>

		<p>
			Есть и другой способ посмотреть на Y-комбинатор. Пусть у нас есть какая-нибудь функция <code>f</code>, и мы хотим вычислить <code>Y f</code>. Проведем &beta;-редукцию:
		</p>

		<pre>
Y f ->
-> (\x. f (x x)) (\x. f (x x)) ->
-> f ((\x. f (x x)) (\x. f (x x))) ->
-> f (Y f)
</pre>

		<p>
			Просто задумайтесь: Y-комбинатор доказывает, что у любой абсолютно произвольной функции существует неподвижная точка! Более того, он конструирует эту неподвижную точку в меньше, чем 30 символов! Поэтому, кстати, Y-комбинатор также называется комбинатором неподвижной точки и в коде нередко обозначается <code>fix</code>. <code>Y</code> и <code>fix</code> &mdash; одно и то же, но мы будем различать их с точки зрения семантики: для задания рекурсивных функций будем использовать <code>Y</code>, для получения неподвижной точки &mdash; <code>fix</code>.
		</p>


		<nav>
			<a href="pt5.html">&leftarrow; V. Списки</a>
			<a href="pt7.html">VII. Очищение &rightarrow;</a>
		</nav>


		<script type="text/javascript" src="js/highlighting.js"></script>
	</body>
</html>
